def ab_to_quantization(ab):
    a, b = ab
    return math.floor(get_index(a)), math.floor(get_index(b))


def quantization_to_ab(abq):
    aq, bq = abq
    a = math.floor((aq * 10)-110)
    b = math.floor((bq * 10)-110)
    return a, b


def one_hot_quantization(ab):
    h, w, _ = ab.shape
    ab_one_hot = np.zeros((h, w, 22, 22))
    for a in range(h):
        for b in range(w):
            one_hot = np.zeros((22, 22))
            aq, bq = ab_to_quantization((a, b))
            one_hot[aq, bq] = 1
            ab_one_hot[a, b, :, :] = one_hot

    return ab_one_hot


def space_to_points():
    space = np.load('./quantized_space/q_space.npy')
    points = np.zeros((space.shape[0], space.shape[1], 2))
    for i in range(space.shape[0]):
        for j in range(space.shape[1]):
            points[i, j] = [space[i, j]*i*10, space[i, j]*j*10]
    return points.flatten()


def create_KDTree():
    points = space_to_points()
    ab = [-55.45, 35.10]
    print(points[spatial.KDTree(points).query(ab)[1]])


def gaussian(v1, v2, sigma, sym=True):
    sig2 = 2 * sigma * sigma
    w = np.exp((v1-v2) ** 2 / sig2)
    return w


def nearest_quantized(ab):
    return


def define_in_gamut(ab_vals):
    space = np.zeros((22, 22))
    q = 0
    for ab in ab_vals:
        a, b = ab_to_quantization(ab)
        if not space[a, b]:
            space[a, b] = 1
            q += 1

    return space, q


if __name__ == '__main__':
    create_KDTree()

def multi_class_cross_entropy_loss_torch(predictions, labels):
    """
    Calculate multi-class cross entropy loss for every pixel in an image, for every image in a batch.
@@ -70,16 +76,46 @@ def multi_class_cross_entropy_loss_torch(predictions, labels):
    - the second sum is over all rows of the image,
    - the third sum is over all columns of the image
    - the last mean is over the batch of images.
    
    :param predictions: Output prediction of the neural network.
    :param labels: Correct labels.
    :return: Computed multi-class cross entropy loss.
    """

    print(predictions[0])
    print(predictions[0].shape)

    loss = -torch.sum(torch.sum(torch.sum(labels *
                                          torch.log(predictions), dim=1), dim=1), dim=1)
    return loss
